# Практикум по Nginx: от основ до Production

### Фаза 1: Основы — хостинг статического сайта

#### Задание 1.1: Установка и базовый запуск

*   **Цель:** Увидеть в браузере страницу, отдаваемую вашим Nginx.

#### Задание 1.2: Виртуальные хосты
Теперь усложним задачу: ваш сервер должен обслуживать два разных сайта.

*   **Цель:** При обращении к `site1.local` и `site2.local` должны открываться разные страницы.

#### Задание 1.3: Маршрутизация с `location`
Научимся управлять обработкой запросов в зависимости от URI.

*   **Цель:** Запросы к `http://site1.local/images/...` должны отдавать файлы из отдельной директории, а `http://site1.local/assets/...` — из другой.

#### Задание 1.4: "Красивые" URL, редиректы и обработка ошибок
Сделаем сайт более дружелюбным к пользователю и поисковым системам.

*   **Цель:** Запрос к `/about` должен открывать страницу `/about.html` без изменения URL в браузере (внутренний реврайт). Старый адрес `/old-contacts` должен делать постоянный `301 редирект` на `/contacts`. При запросе несуществующей страницы должна отображаться ваша кастомная страница ошибки 404.

#### Задание 1.5: Продвинутая маршрутизация с `map`
Освоим более гибкий и производительный способ управления запросами, чем `if`.

*   **Цель:** Реализовать простой A/B тест. С помощью директивы `map` анализировать cookie с именем `version`. Если значение cookie равно `new`, запрос к главной странице должен быть внутренне перенаправлен на `/index-new.html`. Во всех остальных случаях — на `/index-old.html`.


---

### Фаза 2: Динамические приложения — реверс-прокси и балансировка

На этом этапе мы подключим к нашему Nginx бэкенд-приложение.

#### Задание 2.1: Проксирование L4 (TCP) с Proxy Protocol
Выйдем за рамки HTTP и поработаем на транспортном уровне, сохранив информацию о клиенте.

*   **Цель:** Настроить Nginx для проксирования TCP-соединений к базе данных (например, PostgreSQL или MariaDB) с помощью модуля `stream`. При этом необходимо включить **Proxy Protocol** для передачи исходного IP-адреса клиента на бэкенд.


#### Задание 2.2: Весовая и резервная балансировка
Научимся управлять трафиком в гетерогенной среде, где серверы имеют разную мощность.

*   **Цель:** Настроить `upstream` с тремя бэкендами. Одному серверу назначить `weight=5`, а другому — `backup`. Проверить, что трафик на мощный сервер идет значительно чаще, а резервный сервер включается в работу только при остановке основных.


---

### Фаза 3: Безопасность

Защитим наш сервис от угроз.

#### Задание 3.1: Шифрование (TLS/SSL)
Весь трафик должен быть зашифрован.

*   **Цель:** Сайт `site1.local` должен работать по HTTPS с использованием сертификата от Let's Encrypt. Все HTTP-запросы должны автоматически перенаправляться на HTTPS с кодом 301.


#### Задание 3.2: Усиление TLS
Добьемся оценки A+ на SSL Labs.

*   **Цель:** Настроить TLS так, чтобы поддерживались только современные, безопасные протоколы (TLSv1.2, TLSv1.3) и наборы шифров. Включить `OCSP Stapling` для ускорения проверки сертификата и заголовок `HSTS` для защиты от атак понижения протокола.


#### Задание 3.3: Ограничение доступа
Создадим приватную зону, доступную не для всех.

*   **Цель:** Создать `location /admin`, доступ к которому разрешен только с вашего IP-адреса. Затем добавить для этого location дополнительную защиту с помощью базовой аутентификации (логин/пароль).


#### Задание 3.4: Взаимная аутентификация (mTLS)
Реализуем самый строгий способ аутентификации для межсервисного взаимодействия.

*   **Цель:** Настроить `location /private_api` так, чтобы доступ к нему был возможен только при предоставлении валидного клиентского SSL-сертификата, выданного вашим собственным центром сертификации (CA).


#### Задание 3.5: Защита от базовых угроз
Защитим приложение от простого флуда и других векторов атак.

*   **Цель:**
    1.  Настроить ограничение частоты запросов для `location /login` (не более 10 запросов в минуту с одного IP), чтобы защититься от брутфорса.
    2.  Добавить HTTP-заголовки `X-Frame-Options` и `X-Content-Type-Options` для всего сайта.
    3.  Запретить доступ к скрытым файлам и директориям (например, `.git`, `.env`).
    4.  Скрыть версию Nginx в ответах сервера (`server_tokens off`).


#### Задание 3.6: Гибкая авторизация через `auth_request`
Реализуем современный подход к авторизации, делегируя проверку прав внешнему сервису.

*   **Цель:** Защитить `location /protected` с помощью `auth_request`. В качестве сервиса авторизации использовать внутренний `location /_auth`, который проверяет наличие заголовка `X-Api-Key` со значением `secret-key` и возвращает `200 OK` или `403 Forbidden`.


#### Задание 3.7: Политика безопасности контента (CSP)
Реализуем базовую защиту от XSS-атак.

*   **Цель:** Настроить заголовок `Content-Security-Policy` так, чтобы он разрешал загрузку скриптов (`script-src`) и стилей (`style-src`) только с того же домена (`'self'`).


---

### Фаза 4: Оптимизация производительности

Выжмем максимум из нашего сервера.

#### Задание 4.1: Базовое кэширование
Ускорим доставку контента и снизим нагрузку на бэкенд.

*   **Цель:** Настроить два типа кэширования:
    1.  **На стороне клиента:** для статики (CSS, JS, изображения) настроить кэширование в браузере на 1 год с помощью заголовков `Expires` и `Cache-Control`.
    2.  **На стороне сервера:** для ответов API (`/api/v1/data`) настроить кэширование на стороне Nginx на 5 минут с помощью `proxy_cache`.


#### Задание 4.2: Отказоустойчивое и управляемое кэширование
Повысим надежность и управляемость кэша.

*   **Цель:** На базе предыдущего задания усовершенствовать серверное кэширование:
    1.  Настроить `proxy_cache_use_stale` так, чтобы Nginx отдавал устаревший кэш, если бэкенд недоступен.
    2.  Реализовать механизм обхода кэша с помощью `proxy_cache_bypass` при наличии специального заголовка в запросе (например, `X-No-Cache: 1`).
    3.  Включить `proxy_cache_lock` для защиты бэкенда от одновременных запросов на один и тот же ресурс ("стадо бизонов").
    4.  Настроить `location`, который позволит очищать кэш для определенного URL с помощью `proxy_cache_purge` (предполагается, что соответствующий модуль установлен).


#### Задание 4.3: Оптимальное сжатие
Уменьшим объем передаваемых данных, используя лучшие алгоритмы.

*   **Цель:** Включить гибридную схему сжатия. Для статических ресурсов (CSS, JS) использовать **статическое сжатие Brotli** (`.br`). Для динамических ответов (HTML, API) использовать **динамическое сжатие ZSTD** как наиболее быстрое, а **Gzip** оставить в качестве запасного варианта.


#### Задание 4.4: Современные протоколы и форматы

*   **Цель:** Включить поддержку протоколов **HTTP/2** и **HTTP/3 (QUIC)**. Настроить Nginx так, чтобы он отдавал изображения в формате **WebP** или **AVIF**, если браузер их поддерживает, не забыв про заголовок `Vary: Accept`.


#### Задание 4.5: Тонкая настройка Nginx
Поработаем с "сердцем" Nginx для максимальной производительности.

*   **Цель:** Оптимизировать использование процессорных ядер и сетевого стека. Настроить директивы `worker_processes`, `worker_connections`, `sendfile`, `tcp_nopush`. Дополнительно включить `reuseport` на директиве `listen` и настроить кэш открытых файлов (`open_file_cache`).


#### Задание 4.6: Оптимизация соединений с бэкендом
Уменьшим задержки при взаимодействии с бэкенд-сервисами.

*   **Цель:** Настроить пул постоянных **keepalive-соединений** к upstream-серверам, чтобы Nginx не тратил ресурсы на установку нового соединения при каждом запросе.
